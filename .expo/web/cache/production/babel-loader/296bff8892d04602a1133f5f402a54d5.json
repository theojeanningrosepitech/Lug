{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import invariant from'invariant';import qs from'qs';export function buildQueryString(input){return qs.stringify(input);}export function getQueryParams(url){var _parsedSearch$errorCo;var parts=url.split('#');var hash=parts[1];var partsWithoutHash=parts[0].split('?');var queryString=partsWithoutHash[partsWithoutHash.length-1];var parsedSearch=qs.parse(queryString,{parseArrays:false});var errorCode=(_parsedSearch$errorCo=parsedSearch.errorCode)!=null?_parsedSearch$errorCo:null;invariant(typeof errorCode==='string'||errorCode===null,\"The \\\"errorCode\\\" parameter must be a string if specified\");delete parsedSearch.errorCode;var parsedHash={};if(parts[1]){parsedHash=qs.parse(hash);}var params=_objectSpread(_objectSpread({},parsedSearch),parsedHash);return{errorCode:errorCode,params:params};}","map":{"version":3,"sources":["../src/QueryParams.ts"],"names":[],"mappings":"i2BAAA,MAAO,CAAA,SAAP,KAAsB,WAAtB,CACA,MAAO,CAAA,EAAP,KAAe,IAAf,CAEA,MAAM,SAAU,CAAA,gBAAV,CAA2B,KAA3B,CAAwD,CAC5D,MAAO,CAAA,EAAE,CAAC,SAAH,CAAa,KAAb,CAAP,CACD,CAED,MAAM,SAAU,CAAA,cAAV,CACJ,GADI,CACO,2BAEX,GAAM,CAAA,KAAK,CAAG,GAAG,CAAC,KAAJ,CAAU,GAAV,CAAd,CACA,GAAM,CAAA,IAAI,CAAG,KAAK,CAAC,CAAD,CAAlB,CACA,GAAM,CAAA,gBAAgB,CAAG,KAAK,CAAC,CAAD,CAAL,CAAS,KAAT,CAAe,GAAf,CAAzB,CACA,GAAM,CAAA,WAAW,CAAG,gBAAgB,CAAC,gBAAgB,CAAC,MAAjB,CAA0B,CAA3B,CAApC,CAGA,GAAM,CAAA,YAAY,CAAG,EAAE,CAAC,KAAH,CAAS,WAAT,CAAsB,CAAE,WAAW,CAAE,KAAf,CAAtB,CAArB,CAGA,GAAM,CAAA,SAAS,wBAAI,YAAY,CAAC,SAAjB,8BAA8B,IAA7C,CACA,SAAS,CACP,MAAO,CAAA,SAAP,GAAqB,QAArB,EAAiC,SAAS,GAAK,IADxC,6DAAT,CAIA,MAAO,CAAA,YAAY,CAAC,SAApB,CAGA,GAAI,CAAA,UAAU,CAAG,EAAjB,CACA,GAAI,KAAK,CAAC,CAAD,CAAT,CAAc,CACZ,UAAU,CAAG,EAAE,CAAC,KAAH,CAAS,IAAT,CAAb,CACD,CAGD,GAAM,CAAA,MAAM,gCACP,YADO,EAEP,UAFO,CAAZ,CAKA,MAAO,CACL,SAAS,CAAT,SADK,CAEL,MAAM,CAAN,MAFK,CAAP,CAID","sourcesContent":["import invariant from 'invariant';\nimport qs from 'qs';\n\nexport function buildQueryString(input: Record<string, string>): string {\n  return qs.stringify(input);\n}\n\nexport function getQueryParams(\n  url: string\n): { errorCode: string | null; params: { [key: string]: string } } {\n  const parts = url.split('#');\n  const hash = parts[1];\n  const partsWithoutHash = parts[0].split('?');\n  const queryString = partsWithoutHash[partsWithoutHash.length - 1];\n\n  // Get query string (?hello=world)\n  const parsedSearch = qs.parse(queryString, { parseArrays: false });\n\n  // Pull errorCode off of params\n  const errorCode = (parsedSearch.errorCode ?? null) as string | null;\n  invariant(\n    typeof errorCode === 'string' || errorCode === null,\n    `The \"errorCode\" parameter must be a string if specified`\n  );\n  delete parsedSearch.errorCode;\n\n  // Get hash (#abc=example)\n  let parsedHash = {};\n  if (parts[1]) {\n    parsedHash = qs.parse(hash);\n  }\n\n  // Merge search and hash\n  const params = {\n    ...parsedSearch,\n    ...parsedHash,\n  };\n\n  return {\n    errorCode,\n    params,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}