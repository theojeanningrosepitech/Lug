{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{UnavailabilityError}from'@unimodules/core';import{toByteArray}from'base64-js';import ExpoRandom from\"./ExpoRandom\";function assertByteCount(value,methodName){if(typeof value!=='number'||isNaN(value)||Math.floor(value)<0||Math.floor(value)>1024){throw new TypeError(\"expo-random: \"+methodName+\"(\"+value+\") expected a valid number from range 0...1024\");}}export function getRandomBytes(byteCount){assertByteCount(byteCount,'getRandomBytes');var validByteCount=Math.floor(byteCount);if(ExpoRandom.getRandomBytes){return ExpoRandom.getRandomBytes(validByteCount);}else if(ExpoRandom.getRandomBase64String){var base64=ExpoRandom.getRandomBase64String(validByteCount);return toByteArray(base64);}else{throw new UnavailabilityError('expo-random','getRandomBytes');}}export function getRandomBytesAsync(byteCount){var validByteCount,base64;return _regeneratorRuntime.async(function getRandomBytesAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:assertByteCount(byteCount,'getRandomBytesAsync');validByteCount=Math.floor(byteCount);if(!ExpoRandom.getRandomBytesAsync){_context.next=8;break;}_context.next=5;return _regeneratorRuntime.awrap(ExpoRandom.getRandomBytesAsync(validByteCount));case 5:return _context.abrupt(\"return\",_context.sent);case 8:if(!ExpoRandom.getRandomBase64StringAsync){_context.next=15;break;}_context.next=11;return _regeneratorRuntime.awrap(ExpoRandom.getRandomBase64StringAsync(validByteCount));case 11:base64=_context.sent;return _context.abrupt(\"return\",toByteArray(base64));case 15:throw new UnavailabilityError('expo-random','getRandomBytesAsync');case 16:case\"end\":return _context.stop();}}},null,null,null,Promise);}","map":{"version":3,"sources":["../src/Random.ts"],"names":[],"mappings":"4DAAA,OAAS,mBAAT,KAAoC,kBAApC,CACA,OAAS,WAAT,KAA4B,WAA5B,CAEA,MAAO,CAAA,UAAP,oBAEA,QAAS,CAAA,eAAT,CAAyB,KAAzB,CAAqC,UAArC,CAAuD,CACrD,GACE,MAAO,CAAA,KAAP,GAAiB,QAAjB,EACA,KAAK,CAAC,KAAD,CADL,EAEA,IAAI,CAAC,KAAL,CAAW,KAAX,EAAoB,CAFpB,EAGA,IAAI,CAAC,KAAL,CAAW,KAAX,EAAoB,IAJtB,CAKE,CACA,KAAM,IAAI,CAAA,SAAJ,iBACY,UADZ,KAC0B,KAD1B,iDAAN,CAGD,CACF,CAED,MAAM,SAAU,CAAA,cAAV,CAAyB,SAAzB,CAA0C,CAC9C,eAAe,CAAC,SAAD,CAAY,gBAAZ,CAAf,CACA,GAAM,CAAA,cAAc,CAAG,IAAI,CAAC,KAAL,CAAW,SAAX,CAAvB,CACA,GAAI,UAAU,CAAC,cAAf,CAA+B,CAC7B,MAAO,CAAA,UAAU,CAAC,cAAX,CAA0B,cAA1B,CAAP,CACD,CAFD,IAEO,IAAI,UAAU,CAAC,qBAAf,CAAsC,CAC3C,GAAM,CAAA,MAAM,CAAG,UAAU,CAAC,qBAAX,CAAiC,cAAjC,CAAf,CACA,MAAO,CAAA,WAAW,CAAC,MAAD,CAAlB,CACD,CAHM,IAGA,CACL,KAAM,IAAI,CAAA,mBAAJ,CAAwB,aAAxB,CAAuC,gBAAvC,CAAN,CACD,CACF,CAED,MAAO,SAAe,CAAA,mBAAf,CAAmC,SAAnC,yJACL,eAAe,CAAC,SAAD,CAAY,qBAAZ,CAAf,CACM,cAFD,CAEkB,IAAI,CAAC,KAAL,CAAW,SAAX,CAFlB,KAGD,UAAU,CAAC,mBAHV,0EAIU,UAAU,CAAC,mBAAX,CAA+B,cAA/B,CAJV,mEAKM,UAAU,CAAC,0BALjB,4EAMkB,UAAU,CAAC,0BAAX,CAAsC,cAAtC,CANlB,UAMG,MANH,+CAOI,WAAW,CAAC,MAAD,CAPf,eASG,IAAI,CAAA,mBAAJ,CAAwB,aAAxB,CAAuC,qBAAvC,CATH","sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\nimport { toByteArray } from 'base64-js';\n\nimport ExpoRandom from './ExpoRandom';\n\nfunction assertByteCount(value: any, methodName: string): void {\n  if (\n    typeof value !== 'number' ||\n    isNaN(value) ||\n    Math.floor(value) < 0 ||\n    Math.floor(value) > 1024\n  ) {\n    throw new TypeError(\n      `expo-random: ${methodName}(${value}) expected a valid number from range 0...1024`\n    );\n  }\n}\n\nexport function getRandomBytes(byteCount: number): Uint8Array {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytes) {\n    return ExpoRandom.getRandomBytes(validByteCount);\n  } else if (ExpoRandom.getRandomBase64String) {\n    const base64 = ExpoRandom.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\n\nexport async function getRandomBytesAsync(byteCount: number): Promise<Uint8Array> {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytesAsync) {\n    return await ExpoRandom.getRandomBytesAsync(validByteCount);\n  } else if (ExpoRandom.getRandomBase64StringAsync) {\n    const base64 = await ExpoRandom.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytesAsync');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}