{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import*as Crypto from'expo-crypto';import*as Random from'expo-random';import invariant from'invariant';var CHARSET='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';function getRandomValues(input){var output=input;if(input.byteLength!==input.length)input=new Uint8Array(input.buffer);var bytes=Random.getRandomBytes(input.length);for(var i=0;i<bytes.length;i++){input[i]=bytes[i];}return output;}function convertBufferToString(buffer){var state=[];for(var i=0;i<buffer.byteLength;i+=1){var index=buffer[i]%CHARSET.length;state.push(CHARSET[index]);}return state.join('');}function convertToUrlSafeString(b64){return b64.replace(/\\+/g,'-').replace(/\\//g,'_').replace(/=/g,'');}export function generateRandom(size){var buffer=new Uint8Array(size);getRandomValues(buffer);return convertBufferToString(buffer);}export function deriveChallengeAsync(code){var buffer;return _regeneratorRuntime.async(function deriveChallengeAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:invariant(code.length>42&&code.length<129,'Invalid code length for PKCE.');_context.next=3;return _regeneratorRuntime.awrap(Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256,code,{encoding:Crypto.CryptoEncoding.BASE64}));case 3:buffer=_context.sent;return _context.abrupt(\"return\",convertToUrlSafeString(buffer));case 5:case\"end\":return _context.stop();}}},null,null,null,Promise);}export function buildCodeAsync(){var size,codeVerifier,codeChallenge,_args2=arguments;return _regeneratorRuntime.async(function buildCodeAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:size=_args2.length>0&&_args2[0]!==undefined?_args2[0]:128;codeVerifier=generateRandom(size);_context2.next=4;return _regeneratorRuntime.awrap(deriveChallengeAsync(codeVerifier));case 4:codeChallenge=_context2.sent;return _context2.abrupt(\"return\",{codeVerifier:codeVerifier,codeChallenge:codeChallenge});case 6:case\"end\":return _context2.stop();}}},null,null,null,Promise);}export function generateHexStringAsync(size){var value,buffer;return _regeneratorRuntime.async(function generateHexStringAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:value=generateRandom(size);_context3.next=3;return _regeneratorRuntime.awrap(Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256,value,{encoding:Crypto.CryptoEncoding.HEX}));case 3:buffer=_context3.sent;return _context3.abrupt(\"return\",convertToUrlSafeString(buffer));case 5:case\"end\":return _context3.stop();}}},null,null,null,Promise);}","map":{"version":3,"sources":["../src/PKCE.ts"],"names":[],"mappings":"4DAAA,MAAO,GAAK,CAAA,MAAZ,KAAwB,aAAxB,CACA,MAAO,GAAK,CAAA,MAAZ,KAAwB,aAAxB,CACA,MAAO,CAAA,SAAP,KAAsB,WAAtB,CAEA,GAAM,CAAA,OAAO,CAAG,gEAAhB,CAEA,QAAS,CAAA,eAAT,CAAyB,KAAzB,CAA0C,CACxC,GAAM,CAAA,MAAM,CAAG,KAAf,CAEA,GAAI,KAAK,CAAC,UAAN,GAAqB,KAAK,CAAC,MAA/B,CAAuC,KAAK,CAAG,GAAI,CAAA,UAAJ,CAAe,KAAK,CAAC,MAArB,CAAR,CAEvC,GAAM,CAAA,KAAK,CAAG,MAAM,CAAC,cAAP,CAAsB,KAAK,CAAC,MAA5B,CAAd,CAEA,IAAK,GAAI,CAAA,CAAC,CAAG,CAAb,CAAgB,CAAC,CAAG,KAAK,CAAC,MAA1B,CAAkC,CAAC,EAAnC,EAAuC,KAAK,CAAC,CAAD,CAAL,CAAW,KAAK,CAAC,CAAD,CAAhB,CAAvC,CAEA,MAAO,CAAA,MAAP,CACD,CAED,QAAS,CAAA,qBAAT,CAA+B,MAA/B,CAAiD,CAC/C,GAAM,CAAA,KAAK,CAAa,EAAxB,CACA,IAAK,GAAI,CAAA,CAAC,CAAG,CAAb,CAAgB,CAAC,CAAG,MAAM,CAAC,UAA3B,CAAuC,CAAC,EAAI,CAA5C,CAA+C,CAC7C,GAAM,CAAA,KAAK,CAAG,MAAM,CAAC,CAAD,CAAN,CAAY,OAAO,CAAC,MAAlC,CACA,KAAK,CAAC,IAAN,CAAW,OAAO,CAAC,KAAD,CAAlB,EACD,CACD,MAAO,CAAA,KAAK,CAAC,IAAN,CAAW,EAAX,CAAP,CACD,CAED,QAAS,CAAA,sBAAT,CAAgC,GAAhC,CAA2C,CACzC,MAAO,CAAA,GAAG,CACP,OADI,CACI,KADJ,CACW,GADX,EAEJ,OAFI,CAEI,KAFJ,CAEW,GAFX,EAGJ,OAHI,CAGI,IAHJ,CAGU,EAHV,CAAP,CAID,CAED,MAAM,SAAU,CAAA,cAAV,CAAyB,IAAzB,CAAqC,CACzC,GAAM,CAAA,MAAM,CAAG,GAAI,CAAA,UAAJ,CAAe,IAAf,CAAf,CACA,eAAe,CAAC,MAAD,CAAf,CACA,MAAO,CAAA,qBAAqB,CAAC,MAAD,CAA5B,CACD,CAMD,MAAO,SAAe,CAAA,oBAAf,CAAoC,IAApC,2IAEL,SAAS,CAAC,IAAI,CAAC,MAAL,CAAc,EAAd,EAAoB,IAAI,CAAC,MAAL,CAAc,GAAnC,CAAwC,+BAAxC,CAAT,CAFK,iDAIgB,MAAM,CAAC,iBAAP,CAAyB,MAAM,CAAC,qBAAP,CAA6B,MAAtD,CAA8D,IAA9D,CAAoE,CACvF,QAAQ,CAAE,MAAM,CAAC,cAAP,CAAsB,MADuD,CAApE,CAJhB,SAIC,MAJD,+CAOE,sBAAsB,CAAC,MAAD,CAPxB,uEAUP,MAAO,SAAe,CAAA,cAAf,mLACL,IADK,kDACU,GADV,CAIC,YAJD,CAIgB,cAAc,CAAC,IAAD,CAJ9B,mDAKuB,oBAAoB,CAAC,YAAD,CAL3C,SAKC,aALD,iDAOE,CAAE,YAAY,CAAZ,YAAF,CAAgB,aAAa,CAAb,aAAhB,CAPF,wEAaP,MAAO,SAAe,CAAA,sBAAf,CAAsC,IAAtC,sJACC,KADD,CACS,cAAc,CAAC,IAAD,CADvB,mDAEgB,MAAM,CAAC,iBAAP,CAAyB,MAAM,CAAC,qBAAP,CAA6B,MAAtD,CAA8D,KAA9D,CAAqE,CACxF,QAAQ,CAAE,MAAM,CAAC,cAAP,CAAsB,GADwD,CAArE,CAFhB,SAEC,MAFD,iDAKE,sBAAsB,CAAC,MAAD,CALxB","sourcesContent":["import * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\n\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValues(input: Uint8Array): Uint8Array {\n  const output = input;\n  // Get access to the underlying raw bytes\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n\n  const bytes = Random.getRandomBytes(input.length);\n\n  for (let i = 0; i < bytes.length; i++) input[i] = bytes[i];\n\n  return output;\n}\n\nfunction convertBufferToString(buffer: Uint8Array): string {\n  const state: string[] = [];\n  for (let i = 0; i < buffer.byteLength; i += 1) {\n    const index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64: string): string {\n  return b64\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n}\n\nexport function generateRandom(size: number): string {\n  const buffer = new Uint8Array(size);\n  getRandomValues(buffer);\n  return convertBufferToString(buffer);\n}\n\n/**\n * Proof key for Code Exchange by OAuth Public Clients (RFC 7636), Section 4.1\n * [Section 4.1](https://tools.ietf.org/html/rfc7636#section-4.1)\n */\nexport async function deriveChallengeAsync(code: string): Promise<string> {\n  // 43 is the minimum, and 128 is the maximum.\n  invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n    encoding: Crypto.CryptoEncoding.BASE64,\n  });\n  return convertToUrlSafeString(buffer);\n}\n\nexport async function buildCodeAsync(\n  size: number = 128\n): Promise<{ codeChallenge: string; codeVerifier: string }> {\n  // This method needs to be resolved like all other native methods.\n  const codeVerifier = generateRandom(size);\n  const codeChallenge = await deriveChallengeAsync(codeVerifier);\n\n  return { codeVerifier, codeChallenge };\n}\n\n/**\n * Digest a random string with hex encoding, useful for creating `nonce`s.\n */\nexport async function generateHexStringAsync(size: number): Promise<string> {\n  const value = generateRandom(size);\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n    encoding: Crypto.CryptoEncoding.HEX,\n  });\n  return convertToUrlSafeString(buffer);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}