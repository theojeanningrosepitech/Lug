{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _wrapNativeSuper from\"@babel/runtime/helpers/wrapNativeSuper\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import{UnavailabilityError}from'@unimodules/core';import{CryptoDigestAlgorithm,CryptoEncoding}from\"./Crypto.types\";import ExpoCrypto from\"./ExpoCrypto\";export*from\"./Crypto.types\";var CryptoError=function(_TypeError){_inherits(CryptoError,_TypeError);var _super=_createSuper(CryptoError);function CryptoError(message){var _this;_classCallCheck(this,CryptoError);_this=_super.call(this,\"expo-crypto: \"+message);_this.code='ERR_CRYPTO';return _this;}return CryptoError;}(_wrapNativeSuper(TypeError));function assertAlgorithm(algorithm){if(!Object.values(CryptoDigestAlgorithm).includes(algorithm)){throw new CryptoError(\"Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.\"+Object.keys(CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.'));}}function assertData(data){if(typeof data!=='string'){throw new CryptoError(\"Invalid data provided. Expected a string.\");}}function assertEncoding(encoding){if(!Object.values(CryptoEncoding).includes(encoding)){throw new CryptoError(\"Invalid encoding provided. Expected one of: CryptoEncoding.\"+Object.keys(CryptoEncoding).join(', CryptoEncoding.'));}}export function digestStringAsync(algorithm,data){var options,_args=arguments;return _regeneratorRuntime.async(function digestStringAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:options=_args.length>2&&_args[2]!==undefined?_args[2]:{encoding:CryptoEncoding.HEX};if(ExpoCrypto.digestStringAsync){_context.next=3;break;}throw new UnavailabilityError('expo-crypto','digestStringAsync');case 3:assertAlgorithm(algorithm);assertData(data);assertEncoding(options.encoding);_context.next=8;return _regeneratorRuntime.awrap(ExpoCrypto.digestStringAsync(algorithm,data,options));case 8:return _context.abrupt(\"return\",_context.sent);case 9:case\"end\":return _context.stop();}}},null,null,null,Promise);}","map":{"version":3,"sources":["../src/Crypto.ts"],"names":[],"mappings":"ykCAAA,OAAS,mBAAT,KAAoC,kBAApC,CAEA,OAAS,qBAAT,CAAgC,cAAhC,sBACA,MAAO,CAAA,UAAP,oBAEA,4B,GAEM,CAAA,W,6FAGJ,qBAAY,OAAZ,CAA2B,6CACzB,uCAAsB,OAAtB,EAHF,MAAA,IAAA,CAAO,YAAP,CAE2B,aAE1B,C,sCALuB,S,GAQ1B,QAAS,CAAA,eAAT,CAAyB,SAAzB,CAAyD,CACvD,GAAI,CAAC,MAAM,CAAC,MAAP,CAAc,qBAAd,EAAqC,QAArC,CAA8C,SAA9C,CAAL,CAA+D,CAC7D,KAAM,IAAI,CAAA,WAAJ,uEACkE,MAAM,CAAC,IAAP,CACpE,qBADoE,EAEpE,IAFoE,CAE/D,mCAF+D,CADlE,CAAN,CAKD,CACF,CAED,QAAS,CAAA,UAAT,CAAoB,IAApB,CAAgC,CAC9B,GAAI,MAAO,CAAA,IAAP,GAAgB,QAApB,CAA8B,CAC5B,KAAM,IAAI,CAAA,WAAJ,6CAAN,CACD,CACF,CAED,QAAS,CAAA,cAAT,CAAwB,QAAxB,CAAgD,CAC9C,GAAI,CAAC,MAAM,CAAC,MAAP,CAAc,cAAd,EAA8B,QAA9B,CAAuC,QAAvC,CAAL,CAAuD,CACrD,KAAM,IAAI,CAAA,WAAJ,+DAC0D,MAAM,CAAC,IAAP,CAC5D,cAD4D,EAE5D,IAF4D,CAEvD,mBAFuD,CAD1D,CAAN,CAKD,CACF,CAED,MAAO,SAAe,CAAA,iBAAf,CACL,SADK,CAEL,IAFK,yJAGL,OAHK,+CAG0B,CAAE,QAAQ,CAAE,cAAc,CAAC,GAA3B,CAH1B,IAKA,UAAU,CAAC,iBALX,8BAMG,IAAI,CAAA,mBAAJ,CAAwB,aAAxB,CAAuC,mBAAvC,CANH,QASL,eAAe,CAAC,SAAD,CAAf,CACA,UAAU,CAAC,IAAD,CAAV,CACA,cAAc,CAAC,OAAO,CAAC,QAAT,CAAd,CAXK,iDAaQ,UAAU,CAAC,iBAAX,CAA6B,SAA7B,CAAwC,IAAxC,CAA8C,OAA9C,CAbR","sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nimport ExpoCrypto from './ExpoCrypto';\n\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}