{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{Platform}from'@unimodules/core';import Constants,{ExecutionEnvironment}from'expo-constants';import*as Linking from'expo-linking';import{dismissAuthSession,openAuthSessionAsync}from'expo-web-browser';import{AuthRequest}from\"./AuthRequest\";import{CodeChallengeMethod,Prompt,ResponseType}from\"./AuthRequest.types\";import{fetchDiscoveryAsync,resolveDiscoveryAsync}from\"./Discovery\";import{generateHexStringAsync}from\"./PKCE\";import{getQueryParams}from\"./QueryParams\";import sessionUrlProvider from\"./SessionUrlProvider\";var _authLock=false;export function startAsync(options){var authUrl,returnUrl,startUrl,showInRecents,result,_getQueryParams,params,errorCode;return _regeneratorRuntime.async(function startAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:authUrl=options.authUrl;if(authUrl){_context.next=3;break;}throw new Error('No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.');case 3:if(!_authLock){_context.next=6;break;}if(__DEV__){console.warn('Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.');}return _context.abrupt(\"return\",{type:'locked'});case 6:returnUrl=options.returnUrl||sessionUrlProvider.getDefaultReturnUrl();startUrl=sessionUrlProvider.getStartUrl(authUrl,returnUrl);showInRecents=options.showInRecents||false;_authLock=true;_context.prev=10;_context.next=13;return _regeneratorRuntime.awrap(_openWebBrowserAsync(startUrl,returnUrl,showInRecents));case 13:result=_context.sent;case 14:_context.prev=14;_authLock=false;return _context.finish(14);case 17:if(result){_context.next=19;break;}throw new Error('Unexpected missing AuthSession result');case 19:if(result.url){_context.next=25;break;}if(!result.type){_context.next=24;break;}return _context.abrupt(\"return\",result);case 24:throw new Error('Unexpected AuthSession result with missing type');case 25:_getQueryParams=getQueryParams(result.url),params=_getQueryParams.params,errorCode=_getQueryParams.errorCode;return _context.abrupt(\"return\",{type:errorCode?'error':'success',params:params,errorCode:errorCode,authentication:null,url:result.url});case 27:case\"end\":return _context.stop();}}},null,null,[[10,,14,17]],Promise);}export function dismiss(){dismissAuthSession();}export var getDefaultReturnUrl=sessionUrlProvider.getDefaultReturnUrl;export function getRedirectUrl(path){return sessionUrlProvider.getRedirectUrl(path);}export function makeRedirectUri(){var _ref=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},native=_ref.native,scheme=_ref.scheme,isTripleSlashed=_ref.isTripleSlashed,queryParams=_ref.queryParams,path=_ref.path,preferLocalhost=_ref.preferLocalhost,useProxy=_ref.useProxy;if(Platform.OS!=='web'&&native&&[ExecutionEnvironment.Standalone,ExecutionEnvironment.Bare].includes(Constants.executionEnvironment)){return native;}if(!useProxy||Platform.OS==='web'){var url=Linking.createURL(path||'',{isTripleSlashed:isTripleSlashed,scheme:scheme,queryParams:queryParams});if(preferLocalhost){var ipAddress=url.match(/\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/);if(ipAddress!=null&&ipAddress.length){var _url$split=url.split(ipAddress[0]),_url$split2=_slicedToArray(_url$split,2),protocol=_url$split2[0],_path=_url$split2[1];return protocol+\"localhost\"+_path;}}return url;}return sessionUrlProvider.getRedirectUrl(path);}export function loadAsync(config,issuerOrDiscovery){var request,discovery;return _regeneratorRuntime.async(function loadAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:request=new AuthRequest(config);_context2.next=3;return _regeneratorRuntime.awrap(resolveDiscoveryAsync(issuerOrDiscovery));case 3:discovery=_context2.sent;_context2.next=6;return _regeneratorRuntime.awrap(request.makeAuthUrlAsync(discovery));case 6:return _context2.abrupt(\"return\",request);case 7:case\"end\":return _context2.stop();}}},null,null,null,Promise);}function _openWebBrowserAsync(startUrl,returnUrl,showInRecents){var result;return _regeneratorRuntime.async(function _openWebBrowserAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return _regeneratorRuntime.awrap(openAuthSessionAsync(startUrl,returnUrl,{showInRecents:showInRecents}));case 2:result=_context3.sent;if(!(result.type==='cancel'||result.type==='dismiss')){_context3.next=5;break;}return _context3.abrupt(\"return\",{type:result.type});case 5:return _context3.abrupt(\"return\",result);case 6:case\"end\":return _context3.stop();}}},null,null,null,Promise);}export{useAutoDiscovery,useAuthRequest}from\"./AuthRequestHooks\";export{AuthError,TokenError}from\"./Errors\";export{AuthRequest,CodeChallengeMethod,Prompt,ResponseType,resolveDiscoveryAsync,fetchDiscoveryAsync,generateHexStringAsync};export{TokenResponse,AccessTokenRequest,RefreshTokenRequest,RevokeTokenRequest,revokeAsync,refreshAsync,exchangeCodeAsync,fetchUserInfoAsync}from\"./TokenRequest\";export*from\"./TokenRequest.types\";","map":{"version":3,"sources":["../src/AuthSession.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform } from '@unimodules/core';\nimport Constants, { ExecutionEnvironment } from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { dismissAuthSession, openAuthSessionAsync } from 'expo-web-browser';\n\nimport { AuthRequest } from './AuthRequest';\nimport {\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  Prompt,\n  ResponseType,\n} from './AuthRequest.types';\nimport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n} from './AuthSession.types';\nimport {\n  DiscoveryDocument,\n  fetchDiscoveryAsync,\n  Issuer,\n  IssuerOrDiscovery,\n  ProviderMetadata,\n  resolveDiscoveryAsync,\n} from './Discovery';\nimport { generateHexStringAsync } from './PKCE';\nimport { getQueryParams } from './QueryParams';\nimport sessionUrlProvider from './SessionUrlProvider';\n\nlet _authLock = false;\n\nexport async function startAsync(options: AuthSessionOptions): Promise<AuthSessionResult> {\n  const authUrl = options.authUrl;\n  // Prevent accidentally starting to an empty url\n  if (!authUrl) {\n    throw new Error(\n      'No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.'\n    );\n  }\n  // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n  // support it this makes the behavior predictable.\n  if (_authLock) {\n    if (__DEV__) {\n      console.warn(\n        'Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.'\n      );\n    }\n\n    return { type: 'locked' };\n  }\n\n  const returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n  const startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl);\n  const showInRecents = options.showInRecents || false;\n\n  // About to start session, set lock\n  _authLock = true;\n\n  let result;\n  try {\n    result = await _openWebBrowserAsync(startUrl, returnUrl, showInRecents);\n  } finally {\n    // WebBrowser session complete, unset lock\n    _authLock = false;\n  }\n\n  // Handle failures\n  if (!result) {\n    throw new Error('Unexpected missing AuthSession result');\n  }\n  if (!result.url) {\n    if (result.type) {\n      return result;\n    } else {\n      throw new Error('Unexpected AuthSession result with missing type');\n    }\n  }\n\n  const { params, errorCode } = getQueryParams(result.url);\n\n  return {\n    type: errorCode ? 'error' : 'success',\n    params,\n    errorCode,\n    authentication: null,\n    url: result.url,\n  };\n}\n\nexport function dismiss() {\n  dismissAuthSession();\n}\n\nexport const getDefaultReturnUrl = sessionUrlProvider.getDefaultReturnUrl;\n\n/**\n * @deprecated Use `makeRedirectUri({ path, useProxy })` instead.\n *\n * @param path\n */\nexport function getRedirectUrl(path?: string): string {\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\n/**\n * Create a redirect url for the current platform.\n *\n * - **Web:** Generates a path based on the current \\`window.location\\`. For production web apps you should hard code the URL.\n * - **Managed:** Uses the `scheme` property of your `app.config.js` or `app.json`.\n *   - **Proxy:** Uses auth.expo.io as the base URL for the path. This only works in Expo client and standalone environments.\n * - **Bare workflow:** Provide either the `scheme` or a manual `native` property to use.\n *\n * @param options Additional options for configuring the path.\n *\n * @example\n * ```ts\n * const redirectUri = makeRedirectUri({\n *   scheme: 'my-scheme',\n *   path: 'redirect'\n * });\n * // Custom app: my-scheme://redirect\n * // Expo Go: exp://127.0.0.1:19000/--/redirect\n * // Web dev: https://localhost:19006/redirect\n * // Web prod: https://yourwebsite.com/redirect\n *\n * const redirectUri2 = makeRedirectUri({\n *   scheme: 'scheme2',\n *   preferLocalhost: true,\n *   isTripleSlashed: true,\n * });\n * // Custom app: scheme2:///\n * // Expo Go: exp://localhost:19000\n * // Web dev: https://localhost:19006\n * // Web prod: https://yourwebsite.com\n * ```\n *\n * const redirectUri3 = makeRedirectUri({\n *   useProxy: true,\n * });\n * // Custom app: https://auth.expo.io/@username/slug\n * // Expo Go: https://auth.expo.io/@username/slug\n * // Web dev: https://localhost:19006\n * // Web prod: https://yourwebsite.com\n * ```\n */\nexport function makeRedirectUri({\n  native,\n  scheme,\n  isTripleSlashed,\n  queryParams,\n  path,\n  preferLocalhost,\n  useProxy,\n}: AuthSessionRedirectUriOptions = {}): string {\n  if (\n    Platform.OS !== 'web' &&\n    native &&\n    [ExecutionEnvironment.Standalone, ExecutionEnvironment.Bare].includes(\n      Constants.executionEnvironment\n    )\n  ) {\n    // Should use the user-defined native scheme in standalone builds\n    return native;\n  }\n  if (!useProxy || Platform.OS === 'web') {\n    const url = Linking.createURL(path || '', {\n      isTripleSlashed,\n      scheme,\n      queryParams,\n    });\n\n    if (preferLocalhost) {\n      const ipAddress = url.match(\n        /\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/\n      );\n      // Only replace if an IP address exists\n      if (ipAddress?.length) {\n        const [protocol, path] = url.split(ipAddress[0]);\n        return `${protocol}localhost${path}`;\n      }\n    }\n\n    return url;\n  }\n  // Attempt to use the proxy\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\n/**\n * Build an `AuthRequest` and load it before returning.\n *\n * @param config\n * @param issuerOrDiscovery\n */\nexport async function loadAsync(\n  config: AuthRequestConfig,\n  issuerOrDiscovery: IssuerOrDiscovery\n): Promise<AuthRequest> {\n  const request = new AuthRequest(config);\n  const discovery = await resolveDiscoveryAsync(issuerOrDiscovery);\n  await request.makeAuthUrlAsync(discovery);\n  return request;\n}\n\nasync function _openWebBrowserAsync(startUrl: string, returnUrl: string, showInRecents: boolean) {\n  // $FlowIssue: Flow thinks the awaited result can be a promise\n  const result = await openAuthSessionAsync(startUrl, returnUrl, { showInRecents });\n  if (result.type === 'cancel' || result.type === 'dismiss') {\n    return { type: result.type };\n  }\n\n  return result;\n}\n\nexport { useAutoDiscovery, useAuthRequest } from './AuthRequestHooks';\nexport { AuthError, TokenError } from './Errors';\n\nexport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  DiscoveryDocument,\n  Issuer,\n  IssuerOrDiscovery,\n  Prompt,\n  ProviderMetadata,\n  ResponseType,\n  resolveDiscoveryAsync,\n  fetchDiscoveryAsync,\n  generateHexStringAsync,\n};\n\nexport {\n  // Token classes\n  TokenResponse,\n  AccessTokenRequest,\n  RefreshTokenRequest,\n  RevokeTokenRequest,\n  // Token methods\n  revokeAsync,\n  refreshAsync,\n  exchangeCodeAsync,\n  fetchUserInfoAsync,\n} from './TokenRequest';\n\n// Token types\nexport * from './TokenRequest.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}